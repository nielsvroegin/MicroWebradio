Version 3.2 HI-TECH Software Intermediate Code
[v F3 `*uc ~T0 @X0 1 t ]
"6 circBuf.h
[s S1 `C*uc 1 `uc 1 `uc 1 `Cuc 1 ]
[n S1 . buffer head tail maxLen ]
[; ;circBuf.h: 5: typedef volatile struct
[; ;circBuf.h: 6: {
[; ;circBuf.h: 7: unsigned char * const buffer;
[; ;circBuf.h: 8: unsigned char head;
[; ;circBuf.h: 9: unsigned char tail;
[; ;circBuf.h: 10: const unsigned char maxLen;
[; ;circBuf.h: 11: } circBuf_t;
[; ;circBuf.h: 14: inline bit circBufPush(circBuf_t *c, unsigned char data);
[; ;circBuf.h: 17: inline bit circBufPop(circBuf_t *c, unsigned char *data);
[v F11 `(b ~T0 @X0 1 tf2`*VS1`uc ]
"5 circBuf.c
[v _circBufPush `TF11 ~T0 @X0 1 e ]
"6
{
[; ;circBuf.c: 5: inline bit circBufPush(circBuf_t *c, unsigned char data)
[; ;circBuf.c: 6: {
[e :U _circBufPush ]
"5
[v _c `*VS1 ~T0 @X0 1 r1 ]
[v _data `uc ~T0 @X0 1 r2 ]
"6
[f ]
"7
[v _next `uc ~T0 @X0 1 a ]
[; ;circBuf.c: 7: unsigned char next = c->head + 1;
[e = _next -> + -> . *U _c 1 `i -> 1 `i `uc ]
[; ;circBuf.c: 8: if (next >= c->maxLen)
"8
[e $ ! >= -> _next `i -> . *U _c 3 `i 3  ]
[; ;circBuf.c: 9: next = 0;
"9
[e = _next -> -> 0 `i `uc ]
[e :U 3 ]
[; ;circBuf.c: 12: if (next == c->tail)
"12
[e $ ! == -> _next `i -> . *U _c 2 `i 4  ]
[; ;circBuf.c: 13: return 0;
"13
[e ) -> -> 0 `i `b ]
[e $UE 2  ]
[e :U 4 ]
[; ;circBuf.c: 15: c->buffer[c->head] = data;
"15
[e = *U + . *U _c 0 * -> . *U _c 1 `ux -> -> # *U . *U _c 0 `ui `ux _data ]
[; ;circBuf.c: 16: c->head = next;
"16
[e = . *U _c 1 _next ]
[; ;circBuf.c: 17: return 1;
"17
[e ) -> -> 1 `i `b ]
[e $UE 2  ]
[; ;circBuf.c: 18: }
"18
[e :UE 2 ]
}
[v F15 `(b ~T0 @X0 1 tf2`*VS1`*uc ]
"20
[v _circBufPop `TF15 ~T0 @X0 1 e ]
"21
{
[; ;circBuf.c: 20: inline bit circBufPop(circBuf_t *c, unsigned char *data)
[; ;circBuf.c: 21: {
[e :U _circBufPop ]
"20
[v _c `*VS1 ~T0 @X0 1 r1 ]
[v _data `*uc ~T0 @X0 1 r2 ]
"21
[f ]
[; ;circBuf.c: 23: if (c->head == c->tail)
"23
[e $ ! == -> . *U _c 1 `i -> . *U _c 2 `i 6  ]
[; ;circBuf.c: 24: return 0;
"24
[e ) -> -> 0 `i `b ]
[e $UE 5  ]
[e :U 6 ]
[; ;circBuf.c: 26: *data = c->buffer[c->tail];
"26
[e = *U _data *U + . *U _c 0 * -> . *U _c 2 `ux -> -> # *U . *U _c 0 `ui `ux ]
[; ;circBuf.c: 27: c->buffer[c->tail] = 0;
"27
[e = *U + . *U _c 0 * -> . *U _c 2 `ux -> -> # *U . *U _c 0 `ui `ux -> -> 0 `i `uc ]
"29
[v _next `uc ~T0 @X0 1 a ]
[; ;circBuf.c: 29: unsigned char next = c->tail + 1;
[e = _next -> + -> . *U _c 2 `i -> 1 `i `uc ]
[; ;circBuf.c: 30: if(next >= c->maxLen)
"30
[e $ ! >= -> _next `i -> . *U _c 3 `i 7  ]
[; ;circBuf.c: 31: next = 0;
"31
[e = _next -> -> 0 `i `uc ]
[e :U 7 ]
[; ;circBuf.c: 33: c->tail = next;
"33
[e = . *U _c 2 _next ]
[; ;circBuf.c: 35: return 1;
"35
[e ) -> -> 1 `i `b ]
[e $UE 5  ]
[; ;circBuf.c: 36: }
"36
[e :UE 5 ]
}
